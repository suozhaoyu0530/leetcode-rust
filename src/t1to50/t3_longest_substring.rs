/// 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
/// 
/// example 1:
/// 输入: "abcabcbb"
/// 输出: 3 
/// 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
///  
/// example 2:
/// 输入: "bbbbb"
/// 输出: 1
/// 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
///
/// example 3:
/// 输入: "pwwkew"
/// 输出: 3
/// 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
///      请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。


/// 思路：
/// 用一个map将字符出现的位置记录下来
/// 并用一个变量front记录下上次重复的位置，在front之前记录的字符位置不作数需要重新记录
/// 用来排除asdfghdqwea这种情况,d已经重复，所以a-a不作数
pub fn length_of_longest_substring(s: String) -> i32 {
    let front: usize = 0;

}